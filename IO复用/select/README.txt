1. 首先提一下I/O多路转接的基本思路：先构造一张有关描述符的表，然后调用一个函数，它要到这些描述符中的一个已经好进行IO时才返回，在返回时它告诉进程哪一个描述符已准备好进行IO了。

2. select函数的参数告诉内核：
   	(1. 我们所关心的描述符
	(2. 对于每个描述符我们所关心的条件（是否读一个给定的描述符？是否想写一个给定的描述符？是否关心一个描述符的异常条件？）
	(3. 希望等待多长时间（可以永远等待，等待一个固定量时间，或完全不等待）
   select从内核返回后内核会告诉我们：
    (1. 已经准备好的描述符数量
	(2. 哪一个描述符已准备好读、写或异常条件

3. select用于查询设备的状态，以便用户程序获知是否能对设备进行非阻塞的访问，需要设备驱动程序中的poll函数支持。驱动程序中poll函数中最主要用到的一个API是poll_wait，其原型如下：
   void poll_wait(struct file* file, wait_queue_head_t *queue, poll_table* wait);
   poll_wait函数所做的工作是把当前进程添加到wait参数指定的等待列表中(poll_table)中。但是poll_wait并不阻塞，程序中poll_wait(filp, &outq, wait)这句话的意思并不是说一直等待outq信号量可获得，真正的阻塞动作是上层的select/poll函数中完成的。select/poll会在一个循环中对每个需要监听的设备调用它们自己的poll支持函数以使得当前进程被加入各个设备的等待队列表。若当前没有任何被监听的设备就绪，则内核进行调度(调用schedule)让出cpu进入阻塞状态，schedule返回时将再次循环检测是否有操作可以进行，如此反复；否则，若有任意一个设备就绪，select/poll都立即返回。

4. 应用程序调用select()函数，系统调用陷入内核，进入到：
 SYSCALL_DEFINE5(sys_select) -> core_sys_select -> do_select()
 do_select的大概思想就是，当应用程序调用select()函数，内核就会调用poll_wait()，把当前进程添加到相应设备的等待队列上，然后将该应用程序进程设置为睡眠状态。直到该设备上的数据可以获取，然后调用wake up唤醒该应用进程。

